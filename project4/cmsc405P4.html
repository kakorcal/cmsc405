<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<!--
  Using diskplay.html template for setting up webgl configurations  
-->
<head>
<title>Project 4</title>
<style>
    body {
      background-color: #EEEEEE;
      width: 965px;
      margin: 0px auto;
      font-family: Helvetica, sans-serif;
      box-sizing: border-box;
    }
    h1 {
      text-align: center;
    }
    #container {
      margin: 10px 0;
    }
    #controls {
      display: inline-block;
    }
    table {
      border-collapse: collapse;
      width: 280px;
      height: 480px;
    }
    table, th, td {
      border: 1px solid #000;
    }
    table th:first-of-type,
    table td:first-of-type {
      width: 33%;
    }
    table td {
      padding: 0 5px;
    }
    button {
      width: 48%;
      background: #4CAF50;
      color: #fff;
      opacity: 0.7;
    }
    button:hover {
      opacity: 1;
      cursor: pointer;
    }
    /* https://www.w3schools.com/howto/tryit.asp?filename=tryhow_css_js_rangeslider_round */
    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 15px;
      border-radius: 5px;   
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      -webkit-transition: .2s;
      transition: opacity .2s;
    }
    .slider:hover {
      opacity: 1;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 25px;
      height: 25px;
      border-radius: 50%; 
      background: #4CAF50;
      cursor: pointer;
    }
    .slider::-moz-range-thumb {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
    }
</style>

<!-- This shader is exactly as provided -->
<script type="x-shader/x-vertex" id="vshader-source">
  attribute vec3 a_coords;
  attribute vec3 a_normal;   
  uniform mat4 modelview;
  uniform mat4 projection;   
  varying vec3 v_normal;
  varying vec3 v_eyeCoords;  
  void main() {
    vec4 coords = vec4(a_coords,1.0);
    vec4 eyeCoords = modelview * coords;
    gl_Position = projection * eyeCoords;
    v_normal = normalize(a_normal);
    v_eyeCoords = eyeCoords.xyz/eyeCoords.w;         
  }
</script>

<!-- This shader has simplified lighting model and equation. Notice the light only has 3 properties now -->
<script type="x-shader/x-fragment" id="fshader-source">
  #ifdef GL_FRAGMENT_PRECISION_HIGH
     precision highp float;
  #else
     precision mediump float;
  #endif
  struct MaterialProperties {
    vec4 diffuseColor;      
    vec3 specularColor;
    vec3 emissiveColor;
    float specularExponent;
  };
  struct LightProperties {
    bool enabled;
    vec4 position;
    vec3 color;       
  };
  uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
  uniform LightProperties lights[4];
  uniform mat3 normalMatrix;    
  varying vec3 v_normal;
  varying vec3 v_eyeCoords;
  
  vec3 lightingEquation(LightProperties light, MaterialProperties material, 
                            vec3 eyeCoords, vec3 N, vec3 V ) {
       // N is normal vector, V is direction to viewer.
    vec3 L, R; // Light direction and reflected light direction.      
    if ( light.position.w == 0.0 ) {
        L = normalize( light.position.xyz );
    }
    else {
        L = normalize( light.position.xyz/light.position.w - v_eyeCoords );            
    }
    if (dot(L,N) <= 0.0) {
        return vec3(0.0);
    }
    vec3 reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
    R = -reflect(L,N);
    if (dot(R,V) > 0.0) {
        float factor = pow(dot(R,V),material.specularExponent);
        reflection += factor * material.specularColor * light.color;
    }
     return reflection;   
      
  }
  void main() {
    vec3 normal = normalize( normalMatrix*v_normal );
    vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
    vec3 color = material.emissiveColor;
    
    for (int i = 0; i < 4; i++) {
        if (lights[i].enabled) { 
            if (gl_FrontFacing) {
                color += lightingEquation( lights[i], material, v_eyeCoords,
                                                normal, viewDirection);
            }else {
                color += lightingEquation( lights[i], material, v_eyeCoords,
                                                -normal, viewDirection);
            }
        }
    }               
   
    gl_FragColor = vec4(color,material.diffuseColor.a);        
  }
</script>

<script src="./lib/gl-matrix.js"></script>
<script src="./lib/trackball-rotator.js"></script>
<script src="./lib/basic-object-models-IFS.js"></script>
<script src="./lib/teapot-model-IFS.js"></script>
<script>

"use strict";


var gl;   // The webgl context.
var canvas;

var a_coords_loc;         // Location of the a_coords attribute variable in the shader program.
var a_normal_loc;         // Location of a_normal attribute 
var a_texCoords_loc; 
// var texture;

var u_modelview;       // Locations for uniform matrices
var u_projection;
var u_normalMatrix;

var u_material;     // An object tolds uniform locations for the material.
var u_lights;       // An array of objects that holds uniform locations for light properties.

var projection = mat4.create();    // projection matrix
var modelview;                     // modelview matrix; value comes from rotator
var normalMatrix = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors

var rotator;  // A TrackballRotator to implement rotation by mouse.

var animate = {
  cube: {y: 2.5, inc: true, rate: 50, factor: 0.0005, max: 3, min: -3},
  sphere: {rad: 0, inc: true, rate: 50, factor: 0.0005, max: Math.PI*2, min: 0},
  ring: {rad: 0, inc: true, rate: 50, factor: 0.0009, max: Math.PI*2, min:0},
  cone: {},
  cylinder: {
    trans: {x: -2, inc: false, rate: 50, factor: 0.0005, max: -1, min: -3},
    scale: {y: 2, inc: true, rate: 50, factor: 0.0005, max: 3, min: 1},
  },
  triangle: {},
  cross: {},
  teapot: {},
  pyramid: {},
  torus: {rad: 0, inc: true, rate: 50, factor: 0.0009, max: Math.PI*2, min:0}
};

// objects rendered by createModel
var xAxis, yAxis, zAxis;
var torus, sphere, cone, cylinder, triangle, cross, cube, teapot, pyramid, ring;

var matrixStack = [];           // A stack of matrices for implementing hierarchical graphics.

var currentColor = [1,1,1,1];   // The current diffuseColor; render() functions in the basic objects set
                                // the diffuse color to currentColor when it is called before drawing the object.
                                // Other color properties, which don't change often are handled elsewhere.


/**
 * Draws the image, which consists of either the "world" or a closeup of the "car".
 */
function draw() {
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  // https://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html
  /*
    Params
    out: mat4 frustum matrix will be written into
    fovy: Vertical field of view in radians
    aspect: Aspect ratio. typically viewport width/height
    near: Near bound of the frustum
    far: Far bound of the frustum
   */
  mat4.perspective(projection, Math.PI * 0.1666667, canvas.width / canvas.height, 1, 50);
  gl.uniformMatrix4fv(u_projection, false, projection);
  modelview = rotator.getViewMatrix();
  
  lights();
  axes();
  scene();
}

function lights() {   
     
    // Three of four lights used, all enabled
    // Use lights to enhance models looks
    gl.uniform1i( u_lights[0].enabled, 1 );   
    // Looking down z
    gl.uniform4f( u_lights[0].position, 0,0,1,0 ); 
    gl.uniform3f( u_lights[0].color, 1.0,1.0,1.0 );  
    
    gl.uniform1i( u_lights[1].enabled, 1 );  
    // Looking down X
    gl.uniform4f( u_lights[1].position, 1,0,0,0 ); 
    gl.uniform3f( u_lights[1].color, 0.0,1.0,0.0 );  
    
     gl.uniform1i( u_lights[2].enabled, 1 );  
    // Looking down Y
    gl.uniform4f( u_lights[2].position, 0,1,0,0 ); 
    gl.uniform3f( u_lights[2].color, 1.0,0.0,1.0 );   
}

function axes() {
  // axes - adding emissiveColor so that it is not affected by other light sources
  pushMatrix();
  currentColor = [1,0,0,1];
  gl.uniform3fv(u_material.emissiveColor, [1,0,0]);
  xAxis.render(gl.LINES);
  popMatrix();

  pushMatrix();
  currentColor = [0,1,0,1];
  gl.uniform3fv(u_material.emissiveColor, [0,1,0]);
  yAxis.render(gl.LINES);
  popMatrix();

  pushMatrix();
  currentColor = [0,1,1,1];
  gl.uniform3fv(u_material.emissiveColor, [0,1,1]);
  zAxis.render(gl.LINES);
  popMatrix();
  gl.uniform3fv(u_material.emissiveColor, [0,0,0]);
}

/**
 * Note for every push their should be a pop. This resets the transformations
 */
// https://www.tutorialspoint.com/webgl/webgl_quick_guide.htm
function scene() {
  // cube
  pushMatrix();
  mat4.translate(modelview, modelview, [-4, animate.cube.y, 0]);
  currentColor = [0.9,0.4,0.1,1];
  cube.render();
  popMatrix();

  // cylinder
  pushMatrix();
  mat4.translate(modelview, modelview, [animate.cylinder.trans.x, -2, 3]);
  mat4.scale(modelview, modelview, [1, animate.cylinder.scale.y, 1]);
  currentColor = [0.9,0.4,0.1,1];
  cylinder.render();
  popMatrix();

  // torus 
  pushMatrix();
  mat4.translate(modelview, modelview, [-2,0,0]);
  mat4.rotate(modelview, modelview, animate.torus.rad, [1,0,0]);
  currentColor = [0.9,0.4,0.1,1];
  gl.uniform3fv(u_material.emissiveColor, [0.9,0.4,0.1]);
  torus.render();
  gl.uniform3fv(u_material.emissiveColor, [0,0,0]);
  popMatrix();

  // sphere
  pushMatrix();
  mat4.rotate(modelview, modelview, animate.sphere.rad, [0,0,1]);
  mat4.translate(modelview, modelview, [1,2,-1]);
  currentColor = [0.9,0.4,0.1,1];
  gl.uniform3fv(u_material.emissiveColor, [0.9,0.4,0.1]);
  sphere.render();
  gl.uniform3fv(u_material.emissiveColor, [0,0,0]);
  popMatrix();

  // ring
  pushMatrix();
  mat4.rotate(modelview, modelview, animate.sphere.rad, [0,0,1]);
  mat4.translate(modelview, modelview, [1,2,-1]);
  mat4.rotate(modelview, modelview, animate.ring.rad, [0,1,0]);
  ring.render();
  popMatrix();

  // cone 
  pushMatrix();
  mat4.translate(modelview, modelview, [0,-2,1]);
  mat4.rotate(modelview, modelview, -Math.PI*0.5, [1,0,0]);
  currentColor = [0.9,0.4,0.1,1];
  cone.render();
  popMatrix();

  // teapot
  pushMatrix();
  mat4.translate(modelview, modelview, [2.8,-2,0]);
  currentColor = [0.9,0.4,0.1,1];
  teapot.render();
  popMatrix();

  // triangle
  pushMatrix();
  mat4.translate(modelview, modelview, [-2,2,0]);
  currentColor = [0.9,0.4,0.1,1];
  gl.uniform3fv(u_material.emissiveColor, [0.9,0.4,0.1]);
  triangle.render();
  gl.uniform3fv(u_material.emissiveColor, [0,0,0]);
  popMatrix();

  // pyramid
  pushMatrix();
  mat4.translate(modelview, modelview, [2,0,0]);
  currentColor = [0.9,0.4,0.1,1];
  gl.uniform3fv(u_material.emissiveColor, [0.9,0.4,0.1]);
  pyramid.render();
  gl.uniform3fv(u_material.emissiveColor, [0,0,0]);
  popMatrix();

  // cross
  pushMatrix();
  mat4.translate(modelview, modelview, [3,2,-2]);
  currentColor = [0.9,0.4,0.1,1];
  gl.uniform3fv(u_material.emissiveColor, [0.9,0.4,0.1]);
  cross.render();
  gl.uniform3fv(u_material.emissiveColor, [0,0,0]);
  popMatrix();    
}

//----------------------- Shapes --------------------------------

/*
  line, face, triangle, pyramid, and cross function were inspired by the cube function in basic-object-models-IFS.js
 */
function line(vertices, normals, indices) {
  return {
    vertexPositions: new Float32Array(vertices),
    vertexNormals: new Float32Array(normals),
    vertexTextureCoords: new Float32Array([]),
    indices: new Uint16Array(indices)
  };
}

function face(xyz, nrm, coords, normals) {
  var clen = xyz.length;
  var nlen = clen / 3;
  for(var i = 0; i < clen; i++) {
    coords.push(xyz[i]);
  }
  for(var i = 0; i < nlen; i++) {
    normals.push(nrm[0], nrm[1], nrm[2]);
  }
}

function triangle(size) {
  var s = size ? size : 1;
  var w = s * 2;
  var h = Math.sqrt(Math.pow(w, 2) - Math.pow(s, 2));
  var c = h * 0.5;
  var coords = [];
  var normals = [];
  var indices = [
    0,1,2,
    3,4,5,
    6,7,8,6,8,9,
    10,11,12,10,12,13,
    14,15,16,14,16,17
  ];
  
  face([s,-c,s, 0,h-c,s, -s,-c,s], [0,0,1], coords, normals);
  face([s,-c,-s, 0,h-c,-s, -s,-c,-s], [0,0,-1], coords, normals);
  face([s,-c,s, s,-c,-s, 0,h-c,-s, 0,h-c,s], [1,1,0], coords, normals);
  face([-s,-c,s, -s,-c,-s, 0,h-c,-s, 0,h-c,s], [-1,1,0], coords, normals);
  face([s,-c,s, s,-c,-s, -s,-c,-s, -s,-c,s], [0,1,0], coords, normals);

  return {
    vertexPositions: new Float32Array(coords),
    vertexNormals: new Float32Array(normals),
    vertexTextureCoords: new Float32Array([]),
    indices: new Uint16Array(indices)
  };
}

function pyramid(size) {
  var s = size ? size : 1;
  var w = s * 2;
  var h = Math.sqrt(Math.pow(w, 2) - Math.pow(s, 2));
  var c = h * 0.5;
  var coords = [];
  var normals = [];
  var indices = [
    0,1,2,
    3,4,5,
    6,7,8,
    9,10,11,
    12,13,14,12,14,15
  ];

  face([s,-c,s, 0,h-c,0, -s,-c,s], [0,1,1], coords, normals);
  face([s,-c,-s, 0,h-c,0, -s,-c,-s], [0,1,-1], coords, normals);
  face([s,-c,s, 0,h-c,0, s,-c,-s,], [1,1,0], coords, normals);
  face([-s,-c,s, 0,h-c,0, -s,-c,-s], [-1,1,0], coords, normals);
  face([s,-c,s, s,-c,-s, -s,-c,-s, -s,-c,s], [0,1,0], coords, normals);

  return {
    vertexPositions: new Float32Array(coords),
    vertexNormals: new Float32Array(normals),
    vertexTextureCoords: new Float32Array([]),
    indices: new Uint16Array(indices)
  };
}

function cross(size) {
  var s = size ? size : 1;
  var h = s * 0.5;
  var d = s * 2 + h;
  var coords = [];
  var normals = [];
  var indices = [
    0,1,2,0,2,3,
    4,5,6,4,6,7,
    8,9,10,8,10,11,
    12,13,14,12,14,15,
    16,17,18,16,18,19,

    20,21,22,20,22,23,
    24,25,26,24,26,27,
    28,29,30,28,30,31,
    32,33,34,32,34,35,
    36,37,38,36,38,39,

    40,41,42,40,42,43,
    44,45,46,44,46,47,
    48,49,50,48,50,51,
    52,53,54,52,54,55,
    56,57,58,56,58,59,
    60,61,62,60,62,63,
    64,65,66,64,66,67,
    68,69,70,68,70,71,
    72,73,74,72,74,75,
    76,77,78,76,78,79,
    80,81,82,80,82,83,
    84,85,86,84,86,87
  ];

  face([h,h,h, h,-h,h, -h,-h,h, -h,h,h], [0,0,1], coords, normals);
  face([h,d,h, h,h,h, -h,h,h, -h,d,h], [0,0,1], coords, normals);
  face([d,h,h, d,-h,h, h,-h,h, h,h,h], [0,0,1], coords, normals);
  face([h,-h,h, h,-d,h, -h,-d,h, -h,-h,h], [0,0,1], coords, normals);
  face([-h,h,h, -h,-h,h, -d,-h,h, -d,h,h], [0,0,1], coords, normals);

  face([h,h,-h, h,-h,-h, -h,-h,-h, -h,h,-h], [0,0,-1], coords, normals);
  face([h,d,-h, h,h,-h, -h,h,-h, -h,d,-h], [0,0,-1], coords, normals);
  face([d,h,-h, d,-h,-h, h,-h,-h, h,h,-h], [0,0,-1], coords, normals);
  face([h,-h,-h, h,-d,-h, -h,-d,-h, -h,-h,-h], [0,0,-1], coords, normals);
  face([-h,h,-h, -h,-h,-h, -d,-h,-h, -d,h,-h], [0,0,-1], coords, normals);

  face([h,d,h, h,d,-h, -h,d,-h, -h,d,h], [0,1,0], coords, normals);
  face([h,-d,h, h,-d,-h, -h,-d,-h, -h,-d,h], [0,-1,0], coords, normals);

  face([h,d,h, h,h,h, h,h,-h, h,d,-h], [1,0,0], coords, normals);
  face([-h,d,h, -h,h,h, -h,h,-h, -h,d,-h], [-1,0,0], coords, normals);

  face([h,h,h, d,h,h, d,h,-h, h,h,-h], [0,1,0], coords, normals);
  face([-h,h,h, -d,h,h, -d,h,-h, -h,h,-h], [0,1,0], coords, normals);

  face([d,h,h, d,-h,h, d,-h,-h, d,h,-h], [1,0,0], coords, normals);
  face([-d,h,h, -d,-h,h, -d,-h,-h, -d,h,-h], [-1,0,0], coords, normals);

  face([h,-h,h, d,-h,h, d,-h,-h, h,-h,-h], [0,-1,0], coords, normals);
  face([-h,-h,h, -d,-h,h, -d,-h,-h, -h,-h,-h], [0,-1,0], coords, normals);

  face([h,-h,h, h,-d,h, h,-d,-h, h,-h,-h], [1,0,0], coords, normals);
  face([-h,-h,h, -h,-d,h, -h,-d,-h, -h,-h,-h], [-1,0,0], coords, normals);

  return {
    vertexPositions: new Float32Array(coords),
    vertexNormals: new Float32Array(normals),
    vertexTextureCoords: new Float32Array([]),
    indices: new Uint16Array(indices)
  };
}

/**
 *  Push a copy of the current modelview matrix onto the matrix stack.
 */
function pushMatrix() {
  matrixStack.push(mat4.clone(modelview));
}


/**
 *  Restore the modelview matrix to a value popped from the matrix stack.
 */
function popMatrix() {
  modelview = matrixStack.pop();
}

/**
 *  Create one of the basic objects.  The modelData holds the data for
 *  an IFS using the structure from basic-objects-IFS.js.  This function
 *  creates VBOs to hold the coordinates, normal vectors, and indices
 *  from the IFS, and it loads the data into those buffers.  The function
 *  creates a new object whose properties are the identifies of the
 *  VBOs.  The new object also has a function, render(), that can be called to
 *  render the object, using all the data from the buffers.  That object
 *  is returned as the value of the function.  (The second parameter,
 *  xtraTranslate, is there because this program was ported from a Java
 *  version where cylinders were created in a different position, with
 *  the base on the xy-plane instead of with their center at the origin.
 *  The xtraTranslate parameter is a 3-vector that is applied as a
 *  translation to the rendered object.  It is used to move the cylinders
 *  into the position expected by the code that was ported from Java.)
 */
function createModel(modelData, xtraTranslate) {
  var model = {};
  model.coordsBuffer = gl.createBuffer();
  model.normalBuffer = gl.createBuffer();
  model.indexBuffer = gl.createBuffer();
  model.count = modelData.indices.length;

  if(xtraTranslate) {
    model.xtraTranslate = xtraTranslate;  
  }else {
    model.xtraTranslate = null;  
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
  model.render = function(mode) {  // This function will render the object.
       // Since the buffer from which we are taking the coordinates and normals
       // change each time an object is drawn, we have to use gl.vertexAttribPointer
       // to specify the location of the data. And to do that, we must first
       // bind the buffer that contains the data.  Similarly, we have to
       // bind this object's index buffer before calling gl.drawElements.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
    gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
    gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
    gl.uniform4fv(u_material.diffuseColor, currentColor);
    if (this.xtraTranslate) {
      pushMatrix();
      mat4.translate(modelview,modelview,this.xtraTranslate);
    }
    gl.uniformMatrix4fv(u_modelview, false, modelview );
    mat3.normalFromMat4(normalMatrix, modelview);
    gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.drawElements(mode || gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
    if (this.xtraTranslate) {
      popMatrix();
    }
  }
  return model;
}


/* Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type String is thrown.  The error
 * string contains the compilation or linking error.  If no error occurs,
 * the program identifier is the return value of the function.
 *    The second and third parameters are the id attributes for <script>
 * elementst that contain the source code for the vertex and fragment
 * shaders.
 */
function createProgram(gl, vertexShaderID, fragmentShaderID) {
    function getTextContent(elementID) {
      // This nested function retrieves the text content of an
      // element on the web page.  It is used here to get the shader
      // source code from the script elements that contain it.
      var element = document.getElementById(elementID);
      var node = element.firstChild;
      var str = "";
      while (node) {
        if (node.nodeType == 3) // this is a text node
          str += node.textContent;
        node = node.nextSibling;
      }
      return str;
    }

    try {
      var vertexShaderSource = getTextContent( vertexShaderID );
      var fragmentShaderSource = getTextContent( fragmentShaderID );
    }catch(e) {
      throw "Error: Could not get shader source code from script elements.";
    }

    var vsh = gl.createShader( gl.VERTEX_SHADER );
    gl.shaderSource(vsh,vertexShaderSource);
    gl.compileShader(vsh);
    if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
      throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
    }

    var fsh = gl.createShader( gl.FRAGMENT_SHADER );
    gl.shaderSource(fsh, fragmentShaderSource);
    gl.compileShader(fsh);
    if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
     throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
    }

    var prog = gl.createProgram();
    gl.attachShader(prog,vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter( prog, gl.LINK_STATUS)) {
     throw "Link error in program:  " + gl.getProgramInfoLog(prog);
    }
    return prog;
}


/* Initialize the WebGL context.  Called from init() */
function initGL() {
  var prog = createProgram(gl,"vshader-source","fshader-source");
  gl.useProgram(prog);
  gl.enable(gl.DEPTH_TEST);
  
  /* Get attribute and uniform locations */
  
  a_coords_loc = gl.getAttribLocation(prog, "a_coords");
  a_normal_loc = gl.getAttribLocation(prog, "a_normal");
  gl.enableVertexAttribArray(a_coords_loc);
  gl.enableVertexAttribArray(a_normal_loc);
  
  u_modelview = gl.getUniformLocation(prog, "modelview");
  u_projection = gl.getUniformLocation(prog, "projection");
  u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");
  u_material = {
    diffuseColor: gl.getUniformLocation(prog, "material.diffuseColor"),
    specularColor: gl.getUniformLocation(prog, "material.specularColor"),
    emissiveColor: gl.getUniformLocation(prog, "material.emissiveColor"),
    specularExponent: gl.getUniformLocation(prog, "material.specularExponent")
  };

  u_lights = new Array(4);
  for (var i = 0; i < 4; i++) {
    u_lights[i] = {
      enabled: gl.getUniformLocation(prog, "lights[" + i + "].enabled"),
      position: gl.getUniformLocation(prog, "lights[" + i + "].position"),
      color: gl.getUniformLocation(prog, "lights[" + i + "].color")            
    };
  }
          
  gl.uniform3f(u_material.specularColor, 0.1, 0.1, 0.1 );  // specular properties don't change
  gl.uniform1f(u_material.specularExponent, 16 );
  gl.uniform3f(u_material.emissiveColor, 0, 0, 0);  // default, will be changed temporarily for some objects
  
  for (var i = 1; i < 4; i++) { // set defaults for lights
    gl.uniform1i(u_lights[i].enabled, 0 ); 
    gl.uniform4f(u_lights[i].position, 0, 0, 1, 0 );        
    gl.uniform3f(u_lights[i].color, 1,1,1 ); 
  }
    
  // Lights are set on in the draw() method  
} // end initGL()

//--------------------------------- animation framework ------------------------------

/*
This is where you control the animation by changing positions,
and rotations values as needed.
Trial and error works on the numbers. Graph paper design is more efficient. 
*/

function frame() {
  if(animate.cube.inc) {
    if(animate.cube.y <= animate.cube.max) {
      animate.cube.y += animate.cube.rate * animate.cube.factor;
    }else {
      animate.cube.inc = false;
    }
  }else {
    if(animate.cube.y >= animate.cube.min) {
      animate.cube.y -= animate.cube.rate * animate.cube.factor;
    }else {
      animate.cube.inc = true;
    }
  }

  if(animate.sphere.rad <= animate.sphere.max) {
    animate.sphere.rad += animate.sphere.rate * animate.sphere.factor;
  }else {
    animate.sphere.rad = animate.sphere.min;
  }

  if(animate.ring.rad <= animate.ring.max) {
    animate.ring.rad += animate.ring.rate * animate.ring.factor;
  }else {
    animate.ring.rad = animate.ring.min;
  }

  if(animate.torus.rad <= animate.torus.max) {
    animate.torus.rad += animate.torus.rate * animate.torus.factor;
  }else {
    animate.torus.rad = animate.torus.min;
  }

  if(animate.cylinder.trans.inc) {
    if(animate.cylinder.trans.x <= animate.cylinder.trans.max) {
      animate.cylinder.trans.x += animate.cylinder.trans.rate * animate.cylinder.trans.factor;
    }else {
      animate.cylinder.trans.inc = false;
    }
  }else {
    if(animate.cylinder.trans.x >= animate.cylinder.trans.min) {
      animate.cylinder.trans.x -= animate.cylinder.trans.rate * animate.cylinder.trans.factor;
    }else {
      animate.cylinder.trans.inc = true;
    }
  }

  if(animate.cylinder.scale.inc) {
    if(animate.cylinder.scale.y <= animate.cylinder.scale.max) {
      animate.cylinder.scale.y += animate.cylinder.scale.rate * animate.cylinder.scale.factor;
    }else {
      animate.cylinder.scale.inc = false;
    }
  }else {
    if(animate.cylinder.scale.y >= animate.cylinder.scale.min) {
      animate.cylinder.scale.y -= animate.cylinder.scale.rate * animate.cylinder.scale.factor;
    }else {
      animate.cylinder.scale.inc = true;
    }
  }



  draw();
  requestAnimationFrame(frame);
}

//-------------------------------------------------------------------------


/**
 * initialization function that will be called when the page has loaded
 */
function init() {
  try {
    canvas = document.getElementById("webglcanvas");
    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if (!gl) {
      throw "Browser does not support WebGL";
    }
  }catch (e) {
    document.getElementById("container").style.display = "none";
    document.getElementById("message").innerHTML =
        "<p>Sorry, could not get a WebGL graphics context.</p>";
    return;
  }

  try {
    initGL();  // initialize the WebGL graphics context
  }catch (e) {
    document.getElementById("container").style.display = "none";
    document.getElementById("message").innerHTML =
        "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
    return;
  }

  var sliders = document.querySelectorAll("input[type=range]");
  var resetView = document.getElementById('resetView');
  var resetAnimation = document.getElementById('resetAnimation');

  for(var i = 0; i < sliders.length; i++) {
    sliders[i].oninput = function() {
      var shape = animate[this.id];
      if(shape.trans) {
        shape.trans.rate = this.value;
      } 
      if(shape.rot) {
        shape.rot.rate = this.value;
      } 
      if(shape.scale) {
        shape.scale.rate = this.value;
      }
      if(shape.rate) {
        shape.rate = this.value;
      }
      console.log("Id: " + this.id + ", Value: " + this.value);
    }
  }

  resetView.onclick = function() {
    rotator.setView(18, [1,0.5,1]);
    frameNumber = 0;
    console.log("resetting view");
  };

  resetAnimation.onclick = function() {
    for(var i = 0; i < sliders.length; i++) {
      var id = sliders[i].id;
      var shape = animate[id];
      if(shape.trans) {
        shape.trans.rate = 50;
      } 
      if(shape.rot) {
        shape.rot.rate = 50;
      } 
      if(shape.scale) {
        shape.scale.rate = 50;
      }
      if(shape.rate) {
        shape.rate = 50;
      }
      sliders[i].value = 50;
    }
    console.log("resetting animation speed");
  };

  xAxis = createModel(line([-1,0,0, 2,0,0], [0,0,-1, 0,0,2], [0,1]));
  yAxis = createModel(line([0,-1,0, 0,2,0], [-1,0,0, 2,0,0], [0,1]));
  zAxis = createModel(line([0,0,-1, 0,0,2], [0,-1,0, 0,2,0], [0,1]));
  torus = createModel(uvTorus(0.2,0.6,16,8));
  sphere = createModel(uvSphere(0.4));
  ring = createModel(ring(0.4, 0.9, 30));
  cone = createModel(uvCone(), [0,0,.5]);
  cylinder = createModel(uvCylinder(), [0,0,1.5]);
  cube = createModel(cube(0.8));
  for (var i = 0; i < teapotModel.vertexPositions.length; i++) {
    teapotModel.vertexPositions[i] *= 0.06; 
  }
  teapot = createModel(teapotModel);
  triangle = createModel(triangle(0.5));
  pyramid = createModel(pyramid(0.7));
  cross = createModel(cross(0.3));

  // This controls the zoom and initial placement
  rotator = new TrackballRotator(canvas, draw, 18, [1,0.5,1]); 
  requestAnimationFrame(frame);
}

</script>
</head>
<body onload="init()">

<noscript>
  <hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr>
</noscript>

<div id="container">
  <canvas width=680 height=480 id="webglcanvas"></canvas>
  <div id="controls">
    <table>
      <tr>
        <th>Shape</th>
        <th>Animation</th>
      </tr>
      <tr>
        <td>Cube</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="cube" />
        </td>
      </tr>
      <tr>
        <td>Sphere</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="sphere" />
        </td>
      </tr>
      <tr>
        <td>Ring</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="ring" />
        </td>
      </tr>
      <tr>
        <td>Torus</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="torus" />
        </td>
      </tr>
      <tr>
        <td>Cylinder</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="cylinder" />
        </td>
      </tr>
      <tr>
        <td>Cone</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="cone" />
        </td>
      </tr>
      <tr>
        <td>Triangle</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="triangle" />
        </td>
      </tr>
      <tr>
        <td>Pyramid</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="pyramid" />
        </td>
      </tr>
      <tr>
        <td>Cross</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="cross" />
        </td>
      </tr>
      <tr>
        <td>Teapot</td>
        <td>
          <input type="range" min="0" max="100" value="50" class="slider" id="teapot" />
        </td>
      </tr>
      <tr>
        <th>Reset</th>
        <th>
          <button id="resetView">VIEW</button>
          <button id="resetAnimation">ANIMATION</button>
        </th>
      </tr>
    </table>
  </div>
</div>

<h1>WebGL 3D Project</h1>
<div id="message"></div>
</body>
</html>
