<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>Three.js Modeling</title>
<style>
    html, body {
      margin: 0;  /* Make sure that there is no margin around the canvas */
			overflow: hidden;  /* Make sure we don't get scroll bars. */
			position: relative;
			font-family: Helvetica, sans-serif;
    }
    canvas {
      display: block; /* The default display, inline, would add small margin below the canvas */
    }
    table {
    	border-collapse: collapse;
    	background: #292b2c;
    	color: #fff;
    	position: absolute;
    }
    table, th, td {
    	border: 2px solid #fff;
    }
    th, td {
    	padding: 6px;
    }
    td input {
    	width: 100%;
    	text-align: center;
    }
    td input:hover {
    	cursor: pointer;
    }
</style>
<script src="./lib/three.min.js"></script>
<script src="./lib/TrackballControls.js"></script>
<script>

/* This is a starter file for experimenting with 3D animated models
 * in three.js.  The user can rotate the model using the keyboard, and
 * can turn animation on and off.  As an example, it shows  a sphere
 * rotating around a cube.
 *
 * To make your own model, add any global variables that you need for
 * animating the model, build the model in the createWorld() function,
 * and update the animation variables in the updateForFrame() function.
 *
 * For a more complex modeling example using this framework,
 * see diskworld-1.html.
 */

"use strict";

var scene, camera, renderer;  // Three.js rendering basics.

var canvas;  // The canvas on which the image is rendered.

var model;   // Contains the visible objects in the scene, but
             // not the lights or camera.  The model can be
			 // rotated using the keyboard. 

var controls;  // an object of type TrackballControls, the handles roatation using the mouse.

// shapes
var cube;
var pyramid;
var star;
var heart;
var cone;
var sphere;

// var animating = false;  // This is set to true when an animation is running.
var shapes = {
	cube: {animation: true, count: 1, limit: 3, increasing: true},
	pyramid: {animation: true, count: 0, limit: 100},
	heart: {animation: true, count: 0, limit: 100},
	star: {animation: true, count: 0, limit: 100},
	sphere: {animation: true, count: 0, limit: 2},
	cone: {animation: true, count: 0, limit: null}
};

var COLORS = {
	orange: 0xFF9988, 
	pink: 0xFFBBBB, 
	green: 0xAAFFAA, 
	yellow: 0xffff99, 
	magenta: 0xff99ff, 
	cyan: 0x99ffff
}; 

/*  Create the scene graph.  This function is called once, as soon as the page loads.
 *  The renderer has already been created before this function is called.
 */
function createWorld() {
  renderer.setClearColor(0x00000); 
	scene = new THREE.Scene();
	
	// create a camera, sitting on the positive z-axis.  The camera is not part of the scene.
	// fov — Camera frustum vertical field of view.
	// aspect — Camera frustum aspect ratio.
	// near — Camera frustum near plane.
	// far — Camera frustum far plane.

	camera = new THREE.PerspectiveCamera(100, canvas.width / canvas.height, 1, 300);

	var light = new THREE.DirectionalLight(0xffffff, 1.2);
	light.position.set(10, 6, 10);
	camera.position.set(10, 6, 10);
	camera.lookAt(scene.position);
	camera.add(light);
	scene.add(camera);

	// create the model 
	model = new THREE.Object3D();

	cube = cube();
	sphere = sphere();

	// add shapes to model
	// create axes - x:red, y:green, z:blue
	model.add(new THREE.AxisHelper(5));
	model.add(cube);
	model.add(sphere);
		
	scene.add(model);
}

function threeD(shape) {
	var threeD = new THREE.Object3D();
	return threeD.add(shape);
}

function heart() {

}

function cube() {
	var shape = new THREE.Mesh(
	  new THREE.BoxGeometry(1, 1, 1),
		new THREE.MeshPhongMaterial({
			color: COLORS.magenta
		})
	);

	return threeD(shape);
}

function pyramid() {
	return threeD(shape);
}

function star() {
	return threeD(shape);
}

function pyramid() {
	return threeD(shape);
}

function cone() {
	return threeD(shape);
}

// https://github.com/mrdoob/three.js/blob/master/examples/webgl_lights_pointlights.html
function sphere() {
	var shape = new THREE.Mesh(
    new THREE.SphereGeometry(0.5, 16, 8),
		new THREE.MeshBasicMaterial({
			color: COLORS.cyan
		})
	);

	var light = new THREE.PointLight(COLORS.cyan, 1, 50);
	
	light.add(shape);
	light.position.z = shapes.sphere.count;

	return light;
}

/*  Render the scene.  This is called for each frame of the animation.
 */
function render() {
  renderer.render(scene, camera);
}


/*  When an animation is in progress, this function is called just before rendering each
 *  frame of the animation, to make any changes necessary in the scene graph to prepare
 *  for that frame.
 */
function updateForFrame() {
	if(shapes.sphere.animation) {
	  sphere.position.z = Math.cos(shapes.sphere.count * Math.PI) * 8;
	  sphere.position.x = Math.sin(shapes.sphere.count * Math.PI) * 8;
	 	shapes.sphere.count += 0.01; 
	 	if(shapes.sphere.count === shapes.sphere.limit) {
	 		shapes.sphere.count = 0; 
	 	}
	}

	if(shapes.cube.animation) {
		cube.scale.set(shapes.cube.count, shapes.cube.count, shapes.cube.count);
		
		if(shapes.cube.count <= 1) {
			shapes.cube.increasing = true;
		}

		if(shapes.cube.count >= shapes.cube.limit) {
			shapes.cube.increasing = false;
		}

		if(shapes.cube.increasing) {
			shapes.cube.count += 0.01;
		}else {
			shapes.cube.count -= 0.01;
		}
	}
}

//--------------------------- animation support -----------------------------------

/* This function runs the animation by calling updateForFrame() then calling render().
 * Finally, it arranges for itself to be called again to do the next frame.  When the
 * value of animating is set to false, this function does not schedule the next frame,
 * so the animation stops.
 */
function doFrame() {
	updateForFrame();
	controls.update();
	render();
	requestAnimationFrame(doFrame); 
}

function handleAnimationSwitch() {
	for(var shape in shapes) {
		if(shape === this.name) {
			shapes[shape].animation = this.value === 'on' ? true : false;
		}
		console.log("name: " + shape + ", animation: " + shapes[shape].animation);
	}
}

//----------------------- respond to window resizing -------------------------------

/* When the window is resized, we need to adjust the aspect ratio of the camera.
 * We also need to reset the size of the canvas that used by the renderer to
 * match the new size of the window.
 */
 function doResize() {
   camera.aspect = window.innerWidth / window.innerHeight;
   camera.updateProjectionMatrix(); // Need to call this for the change in aspect to take effect.
   renderer.setSize(window.innerWidth, window.innerHeight);
 }


//----------------------------------------------------------------------------------

/**
 *  This init() function is called when by the onload event when the document has loaded.
 */
function init() {
	try {
		renderer = new THREE.WebGLRenderer( {
	    antialias: true
		});
	}catch (e) {
		document.getElementById("canvas-holder").innerHTML =
		         "<h3><b>Sorry, WebGL is required but is not available.</b><h3>";
		return;
	}

	canvas = renderer.domElement;
	renderer.setSize(window.innerWidth, window.innerHeight);
	window.addEventListener("resize", doResize, false); //Set up handler for resize event
	document.body.appendChild(canvas);

	var buttons = document.querySelectorAll('input[type=radio]');

	for(var i = 0; i < buttons.length; i++) {
		buttons[i].onclick = handleAnimationSwitch;
	}
		
	createWorld();
	controls = new THREE.TrackballControls(camera, canvas);
	controls.noPan = true;
	controls.noZoom = true;
	requestAnimationFrame(doFrame);  // Start the animation.
}

</script>
</head>
<body onload="init()">
	<table id="animation">
		<tr>
			<th colspan="3">Animation</th>
		</tr>
		<tr>
			<th>Object</th>
			<th>On</th>
			<th>Off</th>
		</tr>
		<tr>
			<td>Cube</td>
			<td><input type="radio" name="cube" value="on" checked="checked" /></td>
			<td><input type="radio" name="cube" value="off" /></td>
		</tr>
		<tr>
			<td>Pyramid</td>
			<td><input type="radio" name="pyramid" value="on" checked="checked" /></td>
			<td><input type="radio" name="pyramid" value="off" /></td>
		</tr>
		<tr>
			<td>Heart</td>
			<td><input type="radio" name="heart" value="on" checked="checked" /></td>
			<td><input type="radio" name="heart" value="off" /></td>
		</tr>
		<tr>
			<td>Star</td>
			<td><input type="radio" name="star" value="on" checked="checked" /></td>
			<td><input type="radio" name="star" value="off" /></td>
		</tr>
		<tr>
			<td>Sphere</td>
			<td><input type="radio" name="sphere" value="on" checked="checked" /></td>
			<td><input type="radio" name="sphere" value="off" /></td>
		</tr>
		<tr>
			<td>Cone</td>
			<td><input type="radio" name="cone" value="on" checked="checked" /></td>
			<td><input type="radio" name="cone" value="off" /></td>
		</tr>
	</table>
</body>
</html>
