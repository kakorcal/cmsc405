<!doctype html>
<html>
   <head>
      <style>
         body {
            width: 33%;
            margin: 0 auto;
         }
         canvas {
            text-align: center;
            width: 100%;
         }
      </style>
      <script>
         /*
            NOTE: initBuffer, initShaders, bindShaderToBuffer functions
            are inspired by examples in https://www.tutorialspoint.com/webgl/
          */

         /* Step1: Create canvas and initialize WebGL */
         var canvas;
         var gl;
         var WIDTH = 480;
         var HEIGHT = 480;
         
         var vertex_buffer;
         var index_buffer;
         var u_scale;
         var shaderProgram;

         var vertices;
         var indices;

         var scaleX = {
            val: 1,
            factor: 0.01,
            min: 1,
            max: 4.5,
            inc: true
         };

         var scaleY = {
            val: 1,
            factor: 0.02,
            min: 1,
            max: 2,
            inc: true
         };

         function init() {
           canvas = document.createElement("canvas");
           canvas.width = WIDTH;
           canvas.height = HEIGHT;
           document.body.appendChild(canvas);

           try {
             gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
             if(!gl) throw "Browser does not support WebGL";
           }catch(e) {
             document.body.innerHTML = "Browser does not support WebGL";
             return;
           }
           
           try {
             initGL();
           }catch(e) {
             document.body.innerHTML = "Browser does not support WebGL";
             return;
           }
         }

         function initGL() {
            initBuffer();
            initShaders();
            bindShaderToBuffer();
            draw();
         }
         
         /* Step2: Create vertices and store it in buffer objects */
         
         function initBuffer() {
            vertices = [
               -0.2, 0.2, 0.0, 
               -0.2, -0.2, 0.0,
               0.2, -0.2, 0.0,
               0.2, 0.2, 0.0
            ];

            indices = [
               0,1,2,0,2,3,1,2,3
            ];

            // Create a new buffer object
            vertex_buffer = gl.createBuffer();

            // Bind an empty array buffer to it
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            
            // Pass the vertices data to the buffer
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            // Unbind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            // Create an empty buffer object to store Index buffer
            index_buffer = gl.createBuffer();

            // Bind appropriate array buffer to it
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);

            // Pass the vertex data to the buffer
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            // Unbind the buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
         }


         /* Step3: Create and compile Shader programs */

         function initShaders() {
            // Vertex shader source code
            var vertCode =
               'attribute vec4 coordinates;' + 
               'uniform mat4 u_scale;' +
               'void main(void) {' + 
                  ' gl_Position = u_scale * coordinates;' + 
               '}';

            //Create a vertex shader object
            var vertShader = gl.createShader(gl.VERTEX_SHADER);

            //Attach vertex shader source code
            gl.shaderSource(vertShader, vertCode);

            //Compile the vertex shader
            gl.compileShader(vertShader);

            //Fragment shader source code
            var fragCode = 
               'void main(void) {' + 
                  'gl_FragColor = vec4(1.0, 0.0, 0.0, 0.1);' + 
               '}';

            // Create fragment shader object
            var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

            // Attach fragment shader source code
            gl.shaderSource(fragShader, fragCode);

            // Compile the fragment shader
            gl.compileShader(fragShader);

            // Create a shader program object to store combined shader program
            shaderProgram = gl.createProgram();

            // Attach a vertex shader
            gl.attachShader(shaderProgram, vertShader); 
            
            // Attach a fragment shader
            gl.attachShader(shaderProgram, fragShader);

            // Link both programs
            gl.linkProgram(shaderProgram);

            // Use the combined shader program object
            gl.useProgram(shaderProgram);
         }


         /* Step 4: Associate the shader programs to buffer objects */
         
         function bindShaderToBuffer() {            
            u_scale = gl.getUniformLocation(shaderProgram, 'u_scale');

            //Bind vertex buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

            // Bind index buffer object
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);

            //Get the attribute location
            var coordinates = gl.getAttribLocation(shaderProgram, "coordinates");

            //point an attribute to the currently bound VBO
            gl.vertexAttribPointer(coordinates, 3, gl.FLOAT, false, 0, 0);

            //Enable the attribute
            gl.enableVertexAttribArray(coordinates);
         }


         /* Step5: Draw the shape */

         function draw() {
            gl.clearColor(0, 0, 0, 1);
            gl.enable(gl.DEPTH_TEST); 
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            animate();
            gl.drawElements(gl.LINE_LOOP, indices.length, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(draw);
         }

         function animate() {
            scale(scaleX.val, scaleY.val);

            if(scaleX.val <= scaleX.min) {
               scaleX.inc = true;
            }else if(scaleX.val >= scaleX.max) {
               scaleX.inc = false;
            }

            if(scaleY.val <= scaleY.min) {
               scaleY.inc = true;
            }else if(scaleY.val >= scaleY.max) {
               scaleY.inc = false;
            }
            
            if(scaleX.inc) {
               scaleX.val += scaleX.factor;
            }else {
               scaleX.val -= scaleX.factor;
            }

            if(scaleY.inc) {
               scaleY.val += scaleY.factor;
            }else {
               scaleY.val -= scaleY.factor;
            }
         }

         function scale(x, y) {
            var scaleMatrix = new Float32Array([
               x,   0.0,  0.0,  0.0,
               0.0,  y,   0.0,  0.0,
               0.0,  0.0,  1.0,   0.0,
               0.0,  0.0,  0.0,  1.0  
            ]);
            
            gl.uniformMatrix4fv(u_scale, false, scaleMatrix);
         }
         
      </script>
   </head>
   <body onload="init()"></body>
</html>